<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>3D NPC Protect Game</title>
  <style>
    body { margin: 0; overflow: hidden; background:#111; }
    #hud {
      position: absolute; top: 10px; left: 10px; color: white; 
      font-family: Arial, sans-serif; font-size:14px;
    }
    button { margin:5px; padding:6px 10px; font-weight:bold; }
  </style>
</head>
<body>
<div id="hud">
  <button id="restartBtn">Restart NPC</button>
  <button id="clearBtn">Clear Blocks</button>
  <div>Left click: place protective block<br/>Right click: remove last block</div>
</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>

<script>
let scene, camera, renderer;
let npc, npcSpeed = 0.06;
let obstacles = [];
let blocks = [];
let npcAlive = true;

// --- INIT ---
scene = new THREE.Scene();
camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000);
camera.position.set(0, 20, 40);

renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

// Light
const light = new THREE.DirectionalLight(0xffffff, 1);
light.position.set(10, 20, 10);
scene.add(light);
scene.add(new THREE.AmbientLight(0x404040));

// Floor
const floorGeo = new THREE.PlaneGeometry(100, 100);
const floorMat = new THREE.MeshPhongMaterial({color:0x222222});
const floor = new THREE.Mesh(floorGeo, floorMat);
floor.rotation.x = -Math.PI/2;
scene.add(floor);

// --- NPC (sphere) ---
function spawnNPC(){
  if (npc) scene.remove(npc);
  const npcGeo = new THREE.SphereGeometry(1, 16, 16);
  const npcMat = new THREE.MeshPhongMaterial({color:0xffd166});
  npc = new THREE.Mesh(npcGeo, npcMat);
  npc.position.set(0,1,0);
  npc.velocity = new THREE.Vector3(
    (Math.random()-0.5)*npcSpeed,
    0,
    (Math.random()-0.5)*npcSpeed
  );
  scene.add(npc);
  npcAlive = true;
}
spawnNPC();

// --- Obstacles ---
function createObstacles(){
  for (let o of obstacles) scene.remove(o);
  obstacles = [];
  for (let i=0;i<10;i++){
    const boxGeo = new THREE.BoxGeometry(3,3,3);
    const boxMat = new THREE.MeshPhongMaterial({color:0xaa2222});
    const box = new THREE.Mesh(boxGeo, boxMat);
    box.position.set((Math.random()-0.5)*60,1.5,(Math.random()-0.5)*60);
    scene.add(box);
    obstacles.push(box);
  }
}
createObstacles();

// --- Protective Blocks ---
function addBlock(x,z){
  const size = 3;
  const boxGeo = new THREE.BoxGeometry(size,size,size);
  const boxMat = new THREE.MeshPhongMaterial({color:0x3399ff});
  const block = new THREE.Mesh(boxGeo, boxMat);
  block.position.set(x, size/2, z);
  scene.add(block);
  blocks.push(block);
}
function removeBlock(){
  const b = blocks.pop();
  if (b) scene.remove(b);
}

// --- Collision detection ---
function checkCollision(a, b){
  const ab = new THREE.Box3().setFromObject(a);
  const bb = new THREE.Box3().setFromObject(b);
  return ab.intersectsBox(bb);
}

// --- Animation ---
function animate(){
  requestAnimationFrame(animate);

  if (npc && npcAlive){
    // move NPC
    npc.position.add(npc.velocity);

    // bounce off floor bounds
    if (Math.abs(npc.position.x) > 48) npc.velocity.x *= -1;
    if (Math.abs(npc.position.z) > 48) npc.velocity.z *= -1;

    // occasionally randomize direction
    if (Math.random()<0.01){
      npc.velocity.x = (Math.random()-0.5)*npcSpeed;
      npc.velocity.z = (Math.random()-0.5)*npcSpeed;
    }

    // check collision with obstacles
    for (let obs of obstacles){
      let covered = false;
      for (let block of blocks){
        if (checkCollision(obs, block)){
          covered = true; break;
        }
      }
      if (!covered && checkCollision(npc, obs)){
        npcAlive = false;
        npc.material.color.set(0xff0000);
      }
    }
  }

  renderer.render(scene, camera);
}
animate();

// --- Mouse placing blocks ---
window.addEventListener("click", (e)=>{
  if (e.button===0){ // left click
    // project click to ground plane
    const mouse = new THREE.Vector2(
      (e.clientX / window.innerWidth) * 2 - 1,
      -(e.clientY / window.innerHeight) * 2 + 1
    );
    const raycaster = new THREE.Raycaster();
    raycaster.setFromCamera(mouse, camera);
    const intersects = raycaster.intersectObject(floor);
    if (intersects.length>0){
      const p = intersects[0].point;
      addBlock(Math.round(p.x/3)*3, Math.round(p.z/3)*3);
    }
  }
});
window.addEventListener("contextmenu", (e)=>{ e.preventDefault(); removeBlock(); });

// --- Buttons ---
document.getElementById("restartBtn").onclick = ()=>{ spawnNPC(); };
document.getElementById("clearBtn").onclick = ()=>{ for (let b of blocks) scene.remove(b); blocks=[]; };

// Resize
window.addEventListener("resize", ()=>{
  camera.aspect = window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>
</body>
</html>
