<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>2D NPC Smiley Game</title>
  <style>
    body { margin:0; background:#111; overflow:hidden; }
    canvas { display:block; margin:0 auto; background:#222; }
    #hud {
      position:absolute; top:10px; left:10px; color:white; 
      font-family:Arial, sans-serif; background:rgba(0,0,0,0.6);
      padding:10px; border-radius:8px;
    }
    button { margin:5px; padding:5px 10px; font-weight:bold; }
  </style>
</head>
<body>
<div id="hud">
  <button id="restartBtn">Restart NPC</button>
  <button id="clearBtn">Clear Blocks</button>
  <div>Left click: place protective block<br>Right click: remove last block</div>
</div>

<canvas id="gameCanvas"></canvas>

<script>
const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

let npc, npcSpeed = 2.5;
let obstacles = [];
let blocks = [];
let npcAlive = true;

// --- NPC (Smiley face) ---
function spawnNPC(){
  npc = {
    x: canvas.width/2,
    y: canvas.height/2,
    r: 20,
    vx: (Math.random()-0.5)*npcSpeed,
    vy: (Math.random()-0.5)*npcSpeed
  };
  npcAlive = true;
}

// --- Draw NPC ---
function drawNPC(){
  ctx.beginPath();
  ctx.arc(npc.x, npc.y, npc.r, 0, Math.PI*2);
  ctx.fillStyle = npcAlive ? "yellow" : "red";
  ctx.fill();
  ctx.stroke();

  if (npcAlive){
    // smile face
    ctx.fillStyle = "black";
    // eyes
    ctx.beginPath();
    ctx.arc(npc.x-7, npc.y-5, 3, 0, Math.PI*2); ctx.fill();
    ctx.beginPath();
    ctx.arc(npc.x+7, npc.y-5, 3, 0, Math.PI*2); ctx.fill();
    // smile
    ctx.beginPath();
    ctx.arc(npc.x, npc.y+3, 10, 0, Math.PI); 
    ctx.stroke();
  } else {
    // dead face (X eyes)
    ctx.strokeStyle = "black";
    ctx.beginPath(); ctx.moveTo(npc.x-10,npc.y-8); ctx.lineTo(npc.x-4,npc.y-2); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(npc.x-4,npc.y-8); ctx.lineTo(npc.x-10,npc.y-2); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(npc.x+10,npc.y-8); ctx.lineTo(npc.x+4,npc.y-2); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(npc.x+4,npc.y-8); ctx.lineTo(npc.x+10,npc.y-2); ctx.stroke();
    // flat mouth
    ctx.beginPath();
    ctx.moveTo(npc.x-8, npc.y+10);
    ctx.lineTo(npc.x+8, npc.y+10);
    ctx.stroke();
  }
}

// --- Obstacles ---
function createObstacles(){
  obstacles = [];
  for (let i=0; i<15; i++){
    let size = 40;
    obstacles.push({
      x: Math.random()*(canvas.width-100)+50,
      y: Math.random()*(canvas.height-100)+50,
      w: size,
      h: size
    });
  }
}

// --- Draw rectangles ---
function drawRect(obj, color){
  ctx.fillStyle = color;
  ctx.fillRect(obj.x, obj.y, obj.w, obj.h);
}

// --- Collision check (circle vs rect) ---
function circleRectColl(circle, rect){
  let distX = Math.abs(circle.x - rect.x - rect.w/2);
  let distY = Math.abs(circle.y - rect.y - rect.h/2);
  if (distX > (rect.w/2 + circle.r)) return false;
  if (distY > (rect.h/2 + circle.r)) return false;
  if (distX <= (rect.w/2)) return true;
  if (distY <= (rect.h/2)) return true;
  let dx = distX - rect.w/2;
  let dy = distY - rect.h/2;
  return (dx*dx + dy*dy <= (circle.r*circle.r));
}

// --- Game loop ---
function update(){
  ctx.clearRect(0,0,canvas.width,canvas.height);

  // draw obstacles
  for (let o of obstacles) drawRect(o,"brown");
  for (let b of blocks) drawRect(b,"blue");

  // move npc
  if (npcAlive){
    npc.x += npc.vx;
    npc.y += npc.vy;

    // bounce from edges
    if (npc.x-npc.r<0 || npc.x+npc.r>canvas.width) npc.vx *= -1;
    if (npc.y-npc.r<0 || npc.y+npc.r>canvas.height) npc.vy *= -1;

    // occasionally change direction
    if (Math.random()<0.02){
      npc.vx = (Math.random()-0.5)*npcSpeed*2;
      npc.vy = (Math.random()-0.5)*npcSpeed*2;
    }

    // check collision with obstacles
    for (let o of obstacles){
      let covered=false;
      for (let b of blocks){
        if (!(b.x+ b.w < o.x || b.x > o.x+o.w || b.y+b.h<o.y || b.y>o.y+o.h)){
          covered=true; break;
        }
      }
      if (!covered && circleRectColl(npc,o)){
        npcAlive = false;
      }
    }
  }

  // draw npc
  drawNPC();

  requestAnimationFrame(update);
}

// --- Mouse interaction ---
canvas.addEventListener("click",(e)=>{
  const size=40;
  blocks.push({
    x: e.clientX-size/2,
    y: e.clientY-size/2,
    w: size,
    h: size
  });
});
canvas.addEventListener("contextmenu",(e)=>{
  e.preventDefault();
  blocks.pop();
});

// --- Buttons ---
document.getElementById("restartBtn").onclick=()=>{spawnNPC();};
document.getElementById("clearBtn").onclick=()=>{blocks=[];};

// Init
spawnNPC();
createObstacles();
update();

</script>
</body>
</html>
