<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>2D NPC Smiley Game</title>
  <style>
    body { margin:0; background:#111; overflow:hidden; }
    canvas { display:block; margin:0 auto; background:#222; }
    #hud {
      position:absolute; top:10px; left:10px; color:white; 
      font-family:Arial, sans-serif; background:rgba(0,0,0,0.6);
      padding:10px; border-radius:8px;
    }
    button { margin:5px; padding:5px 10px; font-weight:bold; }
  </style>
</head>
<body>
<div id="hud">
  <button id="restartBtn">Restart NPC</button>
  <button id="clearBtn">Clear Blocks</button>
  <div>Left click: place protective block<br>Right click: remove last block</div>
</div>

<canvas id="gameCanvas"></canvas>

<script>
const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

let npc, npcSpeed = 2.5;
let obstacles = [];
let blocks = [];
let npcAlive = true;

// --- NPC ---
function spawnNPC(){
  npc = {
    x: canvas.width/2,
    y: canvas.height/2,
    r: 20,
    vx: (Math.random()-0.5)*npcSpeed,
    vy: (Math.random()-0.5)*npcSpeed
  };
  npcAlive = true;
}

// --- Draw NPC (smiley or dead) ---
function drawNPC(){
  ctx.beginPath();
  ctx.arc(npc.x, npc.y, npc.r, 0, Math.PI*2);
  ctx.fillStyle = npcAlive ? "yellow" : "red";
  ctx.fill();
  ctx.stroke();

  if (npcAlive){
    ctx.fillStyle = "black";
    // eyes
    ctx.beginPath(); ctx.arc(npc.x-7, npc.y-5, 3, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc(npc.x+7, npc.y-5, 3, 0, Math.PI*2); ctx.fill();
    // smile
    ctx.beginPath(); ctx.arc(npc.x, npc.y+3, 10, 0, Math.PI); ctx.stroke();
  } else {
    ctx.strokeStyle = "black";
    // X eyes
    ctx.beginPath(); ctx.moveTo(npc.x-10,npc.y-8); ctx.lineTo(npc.x-4,npc.y-2); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(npc.x-4,npc.y-8); ctx.lineTo(npc.x-10,npc.y-2); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(npc.x+10,npc.y-8); ctx.lineTo(npc.x+4,npc.y-2); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(npc.x+4,npc.y-8); ctx.lineTo(npc.x+10,npc.y-2); ctx.stroke();
    // flat mouth
    ctx.beginPath(); ctx.moveTo(npc.x-8, npc.y+10); ctx.lineTo(npc.x+8, npc.y+10); ctx.stroke();
  }
}

// --- Obstacles ---
function createObstacles(){
  obstacles = [];
  for (let i=0; i<15; i++){
    let size = 40;
    obstacles.push({
      x: Math.random()*(canvas.width-100)+50,
      y: Math.random()*(canvas.height-100)+50,
      w: size,
      h: size
    });
  }
}

// --- Draw rectangle ---
function drawRect(obj, color){
  ctx.fillStyle = color;
  ctx.fillRect(obj.x, obj.y, obj.w, obj.h);
}

// --- Collision check ---
function circleRectColl(circle, rect){
  let distX = Math.abs(circle.x - rect.x - rect.w/2);
  let distY = Math.abs(circle.y - rect.y - rect.h/2);
  if (distX > (rect.w/2 + circle.r)) return false;
  if (distY > (rect.h/2 + circle.r)) return false;
  if (distX <= (rect.w/2)) return true;
  if (distY <= (rect.h/2)) return true;
  let dx = distX - rect.w/2;
  let dy = distY - rect.h/2;
  return (dx*dx + dy*dy <= (circle.r*circle.r));
}

// --- Check overlap (rect vs rect) ---
function rectOverlap(a,b){
  return !(a.x+a.w < b.x || a.x > b.x+b.w || a.y+a.h < b.y || a.y > b.y+b.h);
}

// --- Game loop ---
function update(){
  ctx.clearRect(0,0,canvas.width,canvas.height);

  // draw
  for (let o of obstacles) drawRect(o,"brown");
  for (let b of blocks) drawRect(b,"blue");

  if (npcAlive){
    npc.x += npc.vx;
    npc.y += npc.vy;

    if (npc.x-npc.r<0 || npc.x+npc.r>canvas.width) npc.vx *= -1;
    if (npc.y-npc.r<0 || npc.y+npc.r>canvas.height) npc.vy *= -1;

    if (Math.random()<0.02){
      npc.vx = (Math.random()-0.5)*npcSpeed*2;
      npc.vy = (Math.random()-0.5)*npcSpeed*2;
    }

    for (let o of obstacles){
      let covered=false;
      for (let b of blocks){
        if (rectOverlap(o,b)){ covered=true; break; }
      }
      if (!covered && circleRectColl(npc,o)){
        npcAlive=false;
      }
    }
  }

  drawNPC();
  requestAnimationFrame(update);
}

// --- Place blocks ---
canvas.addEventListener("click",(e)=>{
  const size=40;
  let newBlock = { x:e.clientX-size/2, y:e.clientY-size/2, w:size, h:size };

  // prevent placing on obstacles
  for (let o of obstacles){
    if (rectOverlap(newBlock,o)) return;
  }

  // maintain only 2 blocks
  if (blocks.length >= 2) blocks.shift();
  blocks.push(newBlock);
});

// --- Remove last block ---
canvas.addEventListener("contextmenu",(e)=>{
  e.preventDefault();
  blocks.pop();
});

// --- Buttons ---
document.getElementById("restartBtn").onclick=()=>{spawnNPC();};
document.getElementById("clearBtn").onclick=()=>{blocks=[];};

// Init
spawnNPC();
createObstacles();
update();
</script>
</body>
</html>
